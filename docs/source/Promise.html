<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">// Generated by CoffeeScript 1.3.3
/*
Copyright (c) 2012 [DeftJS Framework Contributors](http://deftjs.org)
Open source under the [MIT License](http://en.wikipedia.org/wiki/MIT_License).

Promise.when(), all(), any(), map() and reduce() methods adapted from:
[when.js](https://github.com/cujojs/when)
Copyright (c) B Cavalier &amp; J Hann
Open source under the [MIT License](http://en.wikipedia.org/wiki/MIT_License).
*/

Carcasse.define('Carcasse.promise.Promise', {
  alternateClassName: ['Carcasse.Promise'],
  statics: {
<span id='global-method-when'>    /**
</span>    		Returns a new {@link Carcasse.promise.Promise} that:
    		- resolves immediately for the specified value, or
    		- resolves, rejects, updates or cancels when the specified {@link Carcasse.promise.Deferred} or {@link Carcasse.promise.Promise} is resolved, rejected, updated or cancelled.
    */

    when: function(promiseOrValue) {
      var deferred;
      if (promiseOrValue instanceof Carcasse.ClassManager.get('Carcasse.promise.Promise') || promiseOrValue instanceof Carcasse.ClassManager.get('Carcasse.promise.Deferred')) {
        return promiseOrValue.then();
      } else {
        deferred = Carcasse.create('Carcasse.promise.Deferred');
        deferred.resolve(promiseOrValue);
        return deferred.then();
      }
    },
<span id='global-method-all'>    /**
</span>    		Returns a new {@link Carcasse.promise.Promise} that will only resolve once all the specified `promisesOrValues` have resolved.
    		The resolution value will be an Array containing the resolution value of each of the `promisesOrValues`.
    */

    all: function(promisesOrValues) {
      var promise, results;
      results = new Array(promisesOrValues.length);
      promise = this.reduce(promisesOrValues, this.reduceIntoArray, results);
      return this.when(promise);
    },
<span id='global-method-any'>    /**
</span>    		Returns a new {@link Carcasse.promise.Promise} that will only resolve once any one of the the specified `promisesOrValues` has resolved.
    		The resolution value will be the resolution value of the triggering `promiseOrValue`.
    */

    any: function(promisesOrValues) {
      var complete, deferred, index, progressFunction, promiseOrValue, rejectFunction, rejecter, resolveFunction, resolver, updater, _i, _len;
      deferred = Carcasse.create('Carcasse.promise.Deferred');
      updater = function(progress) {
        deferred.update(progress);
      };
      resolver = function(value) {
        complete();
        deferred.resolve(value);
      };
      rejecter = function(error) {
        complete();
        deferred.reject(error);
      };
      complete = function() {
        return updater = resolver = rejecter = function() {};
      };
      resolveFunction = function(value) {
        return resolver(value);
      };
      rejectFunction = function(value) {
        return rejector(value);
      };
      progressFunction = function(value) {
        return updater(value);
      };
      for (index = _i = 0, _len = promisesOrValues.length; _i &lt; _len; index = ++_i) {
        promiseOrValue = promisesOrValues[index];
        if (index in promisesOrValues) {
          this.when(promiseOrValue).then(resolveFunction, rejectFunction, progressFunction);
        }
      }
      return this.when(deferred);
    },
<span id='global-method-memoize'>    /**
</span>    		Returns a new function that wraps the specified function and caches the results for previously processed inputs.
    		Similar to `Carcasse.util.Function::memoize()`, except it allows input to contain promises and/or values.
    */

    memoize: function(fn, scope, hashFn) {
      return this.all(Carcasse.Array.toArray(arguments)).then(Carcasse.util.Function.spread(function() {
        return Carcasse.util.memoize(arguments, scope, hashFn);
      }, scope));
    },
<span id='global-method-map'>    /**
</span>    		Traditional map function, similar to `Array.prototype.map()`, that allows input to contain promises and/or values.
    		The specified map function may return either a value or a promise.
    */

    map: function(promisesOrValues, mapFunction) {
      var index, promiseOrValue, results, _i, _len;
      results = new Array(promisesOrValues.length);
      for (index = _i = 0, _len = promisesOrValues.length; _i &lt; _len; index = ++_i) {
        promiseOrValue = promisesOrValues[index];
        if (index in promisesOrValues) {
          results[index] = this.when(promiseOrValue, mapFunction);
        }
      }
      return this.reduce(results, this.reduceIntoArray, results);
    },
<span id='global-method-reduce'>    /**
</span>    		Traditional reduce function, similar to `Array.reduce()`, that allows input to contain promises and/or values.
    */

    reduce: function(promisesOrValues, reduceFunction, initialValue) {
      var reduceArguments, whenResolved;
      whenResolved = this.when;
      reduceArguments = [
        function(previousValueOrPromise, currentValueOrPromise, currentIndex) {
          return whenResolved(previousValueOrPromise, function(previousValue) {
            return whenResolved(currentValueOrPromise, function(currentValue) {
              return reduceFunction(previousValue, currentValue, currentIndex, promisesOrValues);
            });
          });
        }
      ];
      if (arguments.length === 3) {
        reduceArguments.push(initialValue);
      }
      return this.when(this.reduceArray.apply(promisesOrValues, reduceArguments));
    },
<span id='global-method-reduceArray'>    /**
</span>    		Fallback implementation when Array.reduce is not available.
    		@private
    */

    reduceArray: function(reduceFunction, initialValue) {
      var args, array, index, length, reduced;
      index = 0;
      array = Object(this);
      length = array.length &gt;&gt;&gt; 0;
      args = arguments;
      if (args.length &lt;= 1) {
        while (true) {
          if (index in array) {
            reduced = array[index++];
            break;
          }
          if (++index &gt;= length) {
            throw new TypeError();
          }
        }
      } else {
        reduced = args[1];
      }
      while (index &lt; length) {
        if (index in array) {
          reduced = reduceFunction(reduced, array[index], index, array);
        }
        index++;
      }
      return reduced;
    },
<span id='global-method-reduceIntoArray'>    /**
</span>    		@private
    */

    reduceIntoArray: function(previousValue, currentValue, currentIndex) {
      previousValue[currentIndex] = currentValue;
      return previousValue;
    }
  },
  constructor: function(deferred) {
    this.deferred = deferred;
    return this;
  },
<span id='global-method-then'>  /**
</span>  	Returns a new {@link Carcasse.promise.Promise} with the specified callbacks registered to be called when this {@link Carcasse.promise.Promise} is resolved, rejected, updated or cancelled.
  */

  then: function(callbacks) {
    return this.deferred.then.apply(this.deferred, arguments);
  },
<span id='global-method-always'>  /**
</span>  	Returns a new {@link Carcasse.promise.Promise} with the specified callback registered to be called when this {@link Carcasse.promise.Promise} is resolved, rejected or cancelled.
  */

  always: function(callback) {
    return this.deferred.always(callback);
  },
<span id='global-method-cancel'>  /**
</span>  	Cancel this {@link Carcasse.promise.Promise} and notify relevant callbacks.
  */

  cancel: function(reason) {
    return this.deferred.cancel(reason);
  },
<span id='global-method-getState'>  /**
</span>  	Get this {@link Carcasse.promise.Promise}'s current state.
  */

  getState: function() {
    return this.deferred.getState();
  }
}, function() {
  if (Array.prototype.reduce != null) {
    this.reduceArray = Array.prototype.reduce;
  }
});
</pre>
</body>
</html>
