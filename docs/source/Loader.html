<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">
//@tag foundation,core
//@define Carcasse.Loader
//@require Carcasse.ClassManager

<span id='Carcasse-Loader'>/**
</span> * @class Carcasse.Loader
 *
 * @author Jacky Nguyen &lt;jacky@sencha.com&gt;
 * @docauthor Jacky Nguyen &lt;jacky@sencha.com&gt;
 * @aside guide mvc_dependencies
 *
 * Carcasse.Loader is the heart of the new dynamic dependency loading capability in Carcass JS 4+. It is most commonly used
 * via the {@link Carcass#require} shorthand. Carcasse.Loader supports both asynchronous and synchronous loading
 * approaches, and leverage their advantages for the best development flow.
 * We'll discuss about the pros and cons of each approach.
 *
 * __Note:__ The Loader is only enabled by default in development versions of the library (eg sencha-touch-debug.js). To
 * explicitly enable the loader, use `Carcasse.Loader.setConfig({ enabled: true });` before the start of your script.
 *
 * ## Asynchronous Loading
 *
 * - Advantages:
 * 	+ Cross-domain
 * 	+ No web server needed: you can run the application via the file system protocol (i.e: `file://path/to/your/index
 *  .html`)
 * 	+ Best possible debugging experience: error messages come with the exact file name and line number
 *
 * - Disadvantages:
 * 	+ Dependencies need to be specified before-hand
 *
 * ### Method 1: Explicitly include what you need: ###
 *
 *     // Syntax
 *     // Carcasse.require({String/Array} expressions);
 *
 *     // Example: Single alias
 *     Carcasse.require('widget.window');
 *
 *     // Example: Single class name
 *     Carcasse.require('Carcasse.window.Window');
 *
 *     // Example: Multiple aliases / class names mix
 *     Carcasse.require(['widget.window', 'layout.border', 'Carcasse.data.Connection']);
 *
 *     // Wildcards
 *     Carcasse.require(['widget.*', 'layout.*', 'Carcasse.data.*']);
 *
 * ### Method 2: Explicitly exclude what you don't need: ###
 *
 *     // Syntax: Note that it must be in this chaining format.
 *     // Carcasse.exclude({String/Array} expressions)
 *     //    .require({String/Array} expressions);
 *
 *     // Include everything except Carcasse.data.*
 *     Carcasse.exclude('Carcasse.data.*').require('*');
 *
 *     // Include all widgets except widget.checkbox*,
 *     // which will match widget.checkbox, widget.checkboxfield, widget.checkboxgroup, etc.
 *     Carcasse.exclude('widget.checkbox*').require('widget.*');
 *
 * # Synchronous Loading on Demand #
 *
 * - *Advantages:*
 * 	+ There's no need to specify dependencies before-hand, which is always the convenience of including ext-all.js
 *  before
 *
 * - *Disadvantages:*
 * 	+ Not as good debugging experience since file name won't be shown (except in Firebug at the moment)
 * 	+ Must be from the same domain due to XHR restriction
 * 	+ Need a web server, same reason as above
 *
 * There's one simple rule to follow: Instantiate everything with Carcasse.create instead of the `new` keyword
 *
 *     Carcasse.create('widget.window', {}); // Instead of new Carcasse.window.Window({...});
 *
 *     Carcasse.create('Carcasse.window.Window', {}); // Same as above, using full class name instead of alias
 *
 *     Carcasse.widget('window', {}); // Same as above, all you need is the traditional `xtype`
 *
 * Behind the scene, {@link Carcasse.ClassManager} will automatically check whether the given class name / alias has already
 *  existed on the page. If it's not, Carcasse.Loader will immediately switch itself to synchronous mode and automatic load the given
 *  class and all its dependencies.
 *
 * # Hybrid Loading - The Best of Both Worlds #
 *
 * It has all the advantages combined from asynchronous and synchronous loading. The development flow is simple:
 *
 * ### Step 1: Start writing your application using synchronous approach. ###
 * Carcasse.Loader will automatically fetch all dependencies on demand as they're 
 * needed during run-time. For example:
 *
 *     Carcasse.onReady(function(){
 *         var window = Carcasse.createWidget('window', {
 *             width: 500,
 *             height: 300,
 *             layout: {
 *                 type: 'border',
 *                 padding: 5
 *             },
 *             title: 'Hello Dialog',
 *             items: [{
 *                 title: 'Navigation',
 *                 collapsible: true,
 *                 region: 'west',
 *                 width: 200,
 *                 html: 'Hello',
 *                 split: true
 *             }, {
 *                 title: 'TabPanel',
 *                 region: 'center'
 *             }]
 *         });
 *
 *         window.show();
 *     });
 *
 * ### Step 2: Along the way, when you need better debugging ability, watch the console for warnings like these: ###
 *
 *     [Carcasse.Loader] Synchronously loading 'Carcasse.window.Window'; consider adding Carcasse.require('Carcasse.window.Window') before your application's code
 *     ClassManager.js:432
 *     [Carcasse.Loader] Synchronously loading 'Carcasse.layout.container.Border'; consider adding Carcasse.require('Carcasse.layout.container.Border') before your application's code
 *
 * Simply copy and paste the suggested code above `Carcasse.onReady`, i.e:
 *
 *     Carcasse.require('Carcasse.window.Window');
 *     Carcasse.require('Carcasse.layout.container.Border');
 *
 *     Carcasse.onReady(function () {
 *         // ...
 *     });
 *
 * Everything should now load via asynchronous mode.
 *
 * # Deployment #
 *
 * It's important to note that dynamic loading should only be used during development on your local machines.
 * During production, all dependencies should be combined into one single JavaScript file. Carcasse.Loader makes
 * the whole process of transitioning from / to between development / maintenance and production as easy as
 * possible. Internally {@link Carcasse.Loader#history Carcasse.Loader.history} maintains the list of all dependencies your application
 * needs in the exact loading sequence. It's as simple as concatenating all files in this array into one,
 * then include it on top of your application.
 *
 * This process will be automated with Sencha Command, to be released and documented towards Carcass JS 4 Final.
 *
 * @singleton
 */
(function(Manager, Class, flexSetter, alias, pass, arrayFrom, arrayErase, arrayInclude) {

    var dependencyProperties = ['extend', 'mixins', 'requires'],
        Loader,
        setPathCount = 0;

    Loader = Carcasse.Loader = {

<span id='Carcasse-Loader-property-isInHistory'>        /**
</span>         * @private
         */
        isInHistory: {},

<span id='Carcasse-Loader-property-history'>        /**
</span>         * An array of class names to keep track of the dependency loading order.
         * This is not guaranteed to be the same every time due to the asynchronous
         * nature of the Loader.
         *
         * @property history
         * @type Array
         */
        history: [],

<span id='Carcasse-Loader-property-config'>        /**
</span>         * Configuration
         * @private
         */
        config: {
<span id='Carcasse-Loader-cfg-enabled'>            /**
</span>             * Whether or not to enable the dynamic dependency loading feature.
             * @cfg {Boolean} enabled
             */
            enabled: true,

<span id='Carcasse-Loader-cfg-disableCaching'>            /**
</span>             * @cfg {Boolean} disableCaching
             * Appends current timestamp to script files to prevent caching.
             */
            disableCaching: true,

<span id='Carcasse-Loader-cfg-disableCachingParam'>            /**
</span>             * @cfg {String} disableCachingParam
             * The get parameter name for the cache buster's timestamp.
             */
            disableCachingParam: '_dc',

<span id='Carcasse-Loader-cfg-paths'>            /**
</span>             * @cfg {Object} paths
             * The mapping from namespaces to file paths.
             *
             *     {
             *         'Carcass': '.', // This is set by default, Carcasse.layout.container.Container will be
             *                     // loaded from ./layout/Container.js
             *
             *         'My': './src/my_own_folder' // My.layout.Container will be loaded from
             *                                     // ./src/my_own_folder/layout/Container.js
             *     }
             *
             * Note that all relative paths are relative to the current HTML document.
             * If not being specified, for example, `Other.awesome.Class`
             * will simply be loaded from `./Other/awesome/Class.js`.
             */
            paths: {
                'Carcass': '.',
                'App': './app/'
            }
        },

<span id='Carcasse-Loader-method-setConfig'>        /**
</span>         * Set the configuration for the loader. This should be called right after ext-(debug).js
         * is included in the page, and before Carcasse.onReady. i.e:
         *
         *     &lt;script type=&quot;text/javascript&quot; src=&quot;ext-core-debug.js&quot;&gt;&lt;/script&gt;
         *     &lt;script type=&quot;text/javascript&quot;&gt;
         *         Carcasse.Loader.setConfig({
         *           enabled: true,
         *           paths: {
         *               'App': 'my_own_path'
         *           }
         *         });
         *     &lt;script&gt;
         *     &lt;script type=&quot;text/javascript&quot;&gt;
         *         Carcasse.require(...);
         *
         *         Carcasse.onReady(function() {
         *           // application code here
         *         });
         *     &lt;/script&gt;
         *
         * Refer to config options of {@link Carcasse.Loader} for the list of possible properties.
         *
         * @param {Object} config The config object to override the default values.
         * @return {Carcasse.Loader} this
         */
        setConfig: function(name, value) {
            if (Carcasse.isObject(name) &amp;&amp; arguments.length === 1) {
                Carcasse.merge(this.config, name);
            }
            else {
                this.config[name] = (Carcasse.isObject(value)) ? Carcasse.merge(this.config[name], value) : value;
            }

            return this;
        },

<span id='Carcasse-Loader-method-getConfig'>        /**
</span>         * Get the config value corresponding to the specified name. If no name is given, will return the config object.
         * @param {String} name The config property name.
         * @return {Object/Mixed}
         */
        getConfig: function(name) {
            if (name) {
                return this.config[name];
            }

            return this.config;
        },

<span id='Carcasse-Loader-method-setPath'>        /**
</span>         * Sets the path of a namespace.
         * For example:
         *
         *     Carcasse.Loader.setPath('Carcass', '.');
         *
         * @param {String/Object} name See {@link Carcasse.Function#flexSetter flexSetter}
         * @param {String} path See {@link Carcasse.Function#flexSetter flexSetter}
         * @return {Carcasse.Loader} this
         * @method
         */
        setPath: flexSetter(function(name, path) {
            this.config.paths[name] = path;

            return this;
        }),

<span id='Carcasse-Loader-method-addClassPathMappings'>        /**
</span>         * Sets a batch of path entries
         *
         * @param {Object } paths a set of className: path mappings
         * @return {Carcasse.Loader} this
         */
        addClassPathMappings: function(paths) {
            var name;

            if(setPathCount == 0){
                Loader.config.paths = paths;
            } else {
                for(name in paths){
                    Loader.config.paths[name] = paths[name];
                }
            }
            setPathCount++;
            return Loader;
        },

<span id='Carcasse-Loader-method-getPath'>        /**
</span>         * Translates a className to a file path by adding the
         * the proper prefix and converting the .'s to /'s. For example:
         *
         *     Carcasse.Loader.setPath('My', '/path/to/My');
         *
         *     alert(Carcasse.Loader.getPath('My.awesome.Class')); // alerts '/path/to/My/awesome/Class.js'
         *
         * Note that the deeper namespace levels, if explicitly set, are always resolved first. For example:
         *
         *     Carcasse.Loader.setPath({
         *         'My': '/path/to/lib',
         *         'My.awesome': '/other/path/for/awesome/stuff',
         *         'My.awesome.more': '/more/awesome/path'
         *     });
         *
         *     alert(Carcasse.Loader.getPath('My.awesome.Class')); // alerts '/other/path/for/awesome/stuff/Class.js'
         *
         *     alert(Carcasse.Loader.getPath('My.awesome.more.Class')); // alerts '/more/awesome/path/Class.js'
         *
         *     alert(Carcasse.Loader.getPath('My.cool.Class')); // alerts '/path/to/lib/cool/Class.js'
         *
         *     alert(Carcasse.Loader.getPath('Unknown.strange.Stuff')); // alerts 'Unknown/strange/Stuff.js'
         *
         * @param {String} className
         * @return {String} path
         */
        getPath: function(className) {
            var path = '',
                paths = this.config.paths,
                prefix = this.getPrefix(className);

            if (prefix.length &gt; 0) {
                if (prefix === className) {
                    return paths[prefix];
                }

                path = paths[prefix];
                className = className.substring(prefix.length + 1);
            }

            if (path.length &gt; 0) {
                path += '/';
            }

            return path.replace(/\/\.\//g, '/') + className.replace(/\./g, &quot;/&quot;) + '.js';
        },

<span id='Carcasse-Loader-method-getPrefix'>        /**
</span>         * @private
         * @param {String} className
         */
        getPrefix: function(className) {
            var paths = this.config.paths,
                prefix, deepestPrefix = '';

            if (paths.hasOwnProperty(className)) {
                return className;
            }

            for (prefix in paths) {
                if (paths.hasOwnProperty(prefix) &amp;&amp; prefix + '.' === className.substring(0, prefix.length + 1)) {
                    if (prefix.length &gt; deepestPrefix.length) {
                        deepestPrefix = prefix;
                    }
                }
            }

            return deepestPrefix;
        },

<span id='Carcasse-Loader-method-require'>        /**
</span>         * Loads all classes by the given names and all their direct dependencies; optionally executes the given callback function when
         * finishes, within the optional scope. This method is aliased by {@link Carcass#require Carcasse.require} for convenience.
         * @param {String/Array} expressions Can either be a string or an array of string.
         * @param {Function} fn (optional) The callback function.
         * @param {Object} scope (optional) The execution scope (`this`) of the callback function.
         * @param {String/Array} excludes (optional) Classes to be excluded, useful when being used with expressions.
         */
        require: function(expressions, fn, scope, excludes) {
            if (fn) {
                fn.call(scope);
            }
        },

<span id='Carcasse-Loader-method-syncRequire'>        /**
</span>         * Synchronously loads all classes by the given names and all their direct dependencies; optionally executes the given callback function when finishes, within the optional scope. This method is aliased by {@link Carcass#syncRequire} for convenience
         * @param {String/Array} expressions Can either be a string or an array of string
         * @param {Function} fn (optional) The callback function
         * @param {Object} scope (optional) The execution scope (`this`) of the callback function
         * @param {String/Array} excludes (optional) Classes to be excluded, useful when being used with expressions
         */
        syncRequire: function() {},

<span id='Carcasse-Loader-method-exclude'>        /**
</span>         * Explicitly exclude files from being loaded. Useful when used in conjunction with a broad include expression.
         * Can be chained with more `require` and `exclude` methods, eg:
         *
         *     Carcasse.exclude('Carcasse.data.*').require('*');
         *
         *     Carcasse.exclude('widget.button*').require('widget.*');
         *
         * @param {Array} excludes
         * @return {Object} object contains `require` method for chaining.
         */
        exclude: function(excludes) {
            var me = this;

            return {
                require: function(expressions, fn, scope) {
                    return me.require(expressions, fn, scope, excludes);
                },

                syncRequire: function(expressions, fn, scope) {
                    return me.syncRequire(expressions, fn, scope, excludes);
                }
            };
        },

<span id='Carcasse-Loader-method-onReady'>        /**
</span>         * Add a new listener to be executed when all required scripts are fully loaded.
         *
         * @param {Function} fn The function callback to be executed.
         * @param {Object} scope The execution scope (`this`) of the callback function.
         * @param {Boolean} withDomReady Whether or not to wait for document DOM ready as well.
         */
        onReady: function(fn, scope, withDomReady, options) {
            var oldFn;

            if (withDomReady !== false &amp;&amp; Carcasse.onDocumentReady) {
                oldFn = fn;

                fn = function() {
                    Carcasse.onDocumentReady(oldFn, scope, options);
                };
            }

            fn.call(scope);
        }
    };

    //&lt;feature classSystem.loader&gt;
    Carcasse.apply(Loader, {
<span id='Carcasse-Loader-property-documentHead'>        /**
</span>         * @private
         */
        documentHead: typeof document != 'undefined' &amp;&amp; (document.head || document.getElementsByTagName('head')[0]),

<span id='Carcasse-Loader-property-isLoading'>        /**
</span>         * Flag indicating whether there are still files being loaded
         * @private
         */
        isLoading: false,

<span id='Carcasse-Loader-property-queue'>        /**
</span>         * Maintain the queue for all dependencies. Each item in the array is an object of the format:
         * 
         *     {
         *         requires: [...], // The required classes for this queue item
         *         callback: function() { ... } // The function to execute when all classes specified in requires exist
         *     }
         * @private
         */
        queue: [],

<span id='Carcasse-Loader-property-isClassFileLoaded'>        /**
</span>         * Maintain the list of files that have already been handled so that they never get double-loaded
         * @private
         */
        isClassFileLoaded: {},

<span id='Carcasse-Loader-property-isFileLoaded'>        /**
</span>         * @private
         */
        isFileLoaded: {},

<span id='Carcasse-Loader-property-readyListeners'>        /**
</span>         * Maintain the list of listeners to execute when all required scripts are fully loaded
         * @private
         */
        readyListeners: [],

<span id='Carcasse-Loader-property-optionalRequires'>        /**
</span>         * Contains optional dependencies to be loaded last
         * @private
         */
        optionalRequires: [],

<span id='Carcasse-Loader-property-requiresMap'>        /**
</span>         * Map of fully qualified class names to an array of dependent classes.
         * @private
         */
        requiresMap: {},

<span id='Carcasse-Loader-property-numPendingFiles'>        /**
</span>         * @private
         */
        numPendingFiles: 0,

<span id='Carcasse-Loader-property-numLoadedFiles'>        /**
</span>         * @private
         */
        numLoadedFiles: 0,

<span id='Carcasse-Loader-property-hasFileLoadError'>        /** @private */
</span>        hasFileLoadError: false,

<span id='Carcasse-Loader-property-classNameToFilePathMap'>        /**
</span>         * @private
         */
        classNameToFilePathMap: {},

<span id='Carcasse-Loader-property-syncModeEnabled'>        /**
</span>         * @private
         */
        syncModeEnabled: false,

<span id='Carcasse-Loader-property-scriptElements'>        /**
</span>         * @private
         */
        scriptElements: {},

<span id='Carcasse-Loader-method-refreshQueue'>        /**
</span>         * Refresh all items in the queue. If all dependencies for an item exist during looping,
         * it will execute the callback and call refreshQueue again. Triggers onReady when the queue is
         * empty
         * @private
         */
        refreshQueue: function() {
            var queue = this.queue,
                ln = queue.length,
                i, item, j, requires, references;

            if (ln === 0) {
                this.triggerReady();
                return;
            }

            for (i = 0; i &lt; ln; i++) {
                item = queue[i];

                if (item) {
                    requires = item.requires;
                    references = item.references;

                    // Don't bother checking when the number of files loaded
                    // is still less than the array length
                    if (requires.length &gt; this.numLoadedFiles) {
                        continue;
                    }

                    j = 0;

                    do {
                        if (Manager.isCreated(requires[j])) {
                            // Take out from the queue
                            arrayErase(requires, j, 1);
                        }
                        else {
                            j++;
                        }
                    } while (j &lt; requires.length);

                    if (item.requires.length === 0) {
                        arrayErase(queue, i, 1);
                        item.callback.call(item.scope);
                        this.refreshQueue();
                        break;
                    }
                }
            }

            return this;
        },

<span id='Carcasse-Loader-method-injectScriptElement'>        /**
</span>         * Inject a script element to document's head, call onLoad and onError accordingly
         * @private
         */
        injectScriptElement: function(url, onLoad, onError, scope) {
            var script = document.createElement('script'),
                me = this,
                onLoadFn = function() {
                    me.cleanupScriptElement(script);
                    onLoad.call(scope);
                },
                onErrorFn = function() {
                    me.cleanupScriptElement(script);
                    onError.call(scope);
                };

            script.type = 'text/javascript';
            script.src = url;
            script.onload = onLoadFn;
            script.onerror = onErrorFn;
            script.onreadystatechange = function() {
                if (this.readyState === 'loaded' || this.readyState === 'complete') {
                    onLoadFn();
                }
            };

            this.documentHead.appendChild(script);

            return script;
        },

        removeScriptElement: function(url) {
            var scriptElements = this.scriptElements;

            if (scriptElements[url]) {
                this.cleanupScriptElement(scriptElements[url], true);
                delete scriptElements[url];
            }

            return this;
        },

<span id='Carcasse-Loader-method-cleanupScriptElement'>        /**
</span>         * @private
         */
        cleanupScriptElement: function(script, remove) {
            script.onload = null;
            script.onreadystatechange = null;
            script.onerror = null;

            if (remove) {
                this.documentHead.removeChild(script);
            }

            return this;
        },

<span id='Carcasse-Loader-method-loadScriptFile'>        /**
</span>         * Load a script file, supports both asynchronous and synchronous approaches
         *
         * @param {String} url
         * @param {Function} onLoad
         * @param {Object} scope
         * @param {Boolean} synchronous
         * @private
         */
        loadScriptFile: function(url, onLoad, onError, scope, synchronous) {
            var me = this,
                isFileLoaded = this.isFileLoaded,
                scriptElements = this.scriptElements,
                noCacheUrl = url + (this.getConfig('disableCaching') ? ('?' + this.getConfig('disableCachingParam') + '=' + Carcasse.Date.now()) : ''),
                xhr, status, content, onScriptError;

            if (isFileLoaded[url]) {
                return this;
            }

            scope = scope || this;

            this.isLoading = true;

            if (!synchronous) {
                onScriptError = function() {
                    //&lt;debug error&gt;
                    onError.call(scope, &quot;Failed loading '&quot; + url + &quot;', please verify that the file exists&quot;, synchronous);
                    //&lt;/debug&gt;
                };

                if (!Carcasse.isReady &amp;&amp; Carcasse.onDocumentReady) {
                    Carcasse.onDocumentReady(function() {
                        if (!isFileLoaded[url]) {
                            scriptElements[url] = me.injectScriptElement(noCacheUrl, onLoad, onScriptError, scope);
                        }
                    });
                }
                else {
                    scriptElements[url] = this.injectScriptElement(noCacheUrl, onLoad, onScriptError, scope);
                }
            }
            else {
                if (typeof XMLHttpRequest != 'undefined') {
                    xhr = new XMLHttpRequest();
                } else {
                    xhr = new ActiveXObject('Microsoft.XMLHTTP');
                }

                try {
                    xhr.open('GET', noCacheUrl, false);
                    xhr.send(null);
                }
                catch (e) {
                    //&lt;debug error&gt;
                    onError.call(this, &quot;Failed loading synchronously via XHR: '&quot; + url + &quot;'; It's likely that the file is either &quot; +
                                       &quot;being loaded from a different domain or from the local file system whereby cross origin &quot; +
                                       &quot;requests are not allowed due to security reasons. Use asynchronous loading with &quot; +
                                       &quot;Carcasse.require instead.&quot;, synchronous);
                    //&lt;/debug&gt;
                }

                status = (xhr.status == 1223) ? 204 : xhr.status;
                content = xhr.responseText;

                if ((status &gt;= 200 &amp;&amp; status &lt; 300) || status == 304 || (status == 0 &amp;&amp; content.length &gt; 0)) {
                    // Debugger friendly, file names are still shown even though they're eval'ed code
                    // Breakpoints work on both Firebug and Chrome's Web Inspector
                    Carcasse.globalEval(content + &quot;\n//@ sourceURL=&quot; + url);
                    onLoad.call(scope);
                }
                else {
                    //&lt;debug&gt;
                    onError.call(this, &quot;Failed loading synchronously via XHR: '&quot; + url + &quot;'; please &quot; +
                                       &quot;verify that the file exists. &quot; +
                                       &quot;XHR status code: &quot; + status, synchronous);
                    //&lt;/debug&gt;
                }

                // Prevent potential IE memory leak
                xhr = null;
            }
        },

        // documented above
        syncRequire: function() {
            var syncModeEnabled = this.syncModeEnabled;

            if (!syncModeEnabled) {
                this.syncModeEnabled = true;
            }

            this.require.apply(this, arguments);

            if (!syncModeEnabled) {
                this.syncModeEnabled = false;
            }

            this.refreshQueue();
        },

        // documented above
        require: function(expressions, fn, scope, excludes) {
            var excluded = {},
                included = {},
                queue = this.queue,
                classNameToFilePathMap = this.classNameToFilePathMap,
                isClassFileLoaded = this.isClassFileLoaded,
                excludedClassNames = [],
                possibleClassNames = [],
                classNames = [],
                references = [],
                callback,
                syncModeEnabled,
                filePath, expression, exclude, className,
                possibleClassName, i, j, ln, subLn;

            if (excludes) {
                excludes = arrayFrom(excludes);

                for (i = 0,ln = excludes.length; i &lt; ln; i++) {
                    exclude = excludes[i];

                    if (typeof exclude == 'string' &amp;&amp; exclude.length &gt; 0) {
                        excludedClassNames = Manager.getNamesByExpression(exclude);

                        for (j = 0,subLn = excludedClassNames.length; j &lt; subLn; j++) {
                            excluded[excludedClassNames[j]] = true;
                        }
                    }
                }
            }

            expressions = arrayFrom(expressions);

            if (fn) {
                if (fn.length &gt; 0) {
                    callback = function() {
                        var classes = [],
                            i, ln, name;

                        for (i = 0,ln = references.length; i &lt; ln; i++) {
                            name = references[i];
                            classes.push(Manager.get(name));
                        }

                        return fn.apply(this, classes);
                    };
                }
                else {
                    callback = fn;
                }
            }
            else {
                callback = Carcasse.emptyFn;
            }

            scope = scope || Carcasse.global;

            for (i = 0,ln = expressions.length; i &lt; ln; i++) {
                expression = expressions[i];

                if (typeof expression == 'string' &amp;&amp; expression.length &gt; 0) {
                    possibleClassNames = Manager.getNamesByExpression(expression);
                    subLn = possibleClassNames.length;

                    for (j = 0; j &lt; subLn; j++) {
                        possibleClassName = possibleClassNames[j];

                        if (excluded[possibleClassName] !== true) {
                            references.push(possibleClassName);

                            if (!Manager.isCreated(possibleClassName) &amp;&amp; !included[possibleClassName]) {
                                included[possibleClassName] = true;
                                classNames.push(possibleClassName);
                            }
                        }
                    }
                }
            }

            // If the dynamic dependency feature is not being used, throw an error
            // if the dependencies are not defined
            if (classNames.length &gt; 0) {
                if (!this.config.enabled) {
                    throw new Error(&quot;Carcasse.Loader is not enabled, so dependencies cannot be resolved dynamically. &quot; +
                             &quot;Missing required class&quot; + ((classNames.length &gt; 1) ? &quot;es&quot; : &quot;&quot;) + &quot;: &quot; + classNames.join(', '));
                }
            }
            else {
                callback.call(scope);
                return this;
            }

            syncModeEnabled = this.syncModeEnabled;

            if (!syncModeEnabled) {
                queue.push({
                    requires: classNames.slice(), // this array will be modified as the queue is processed,
                                                  // so we need a copy of it
                    callback: callback,
                    scope: scope
                });
            }

            ln = classNames.length;

            for (i = 0; i &lt; ln; i++) {
                className = classNames[i];

                filePath = this.getPath(className);

                // If we are synchronously loading a file that has already been asynchronously loaded before
                // we need to destroy the script tag and revert the count
                // This file will then be forced loaded in synchronous
                if (syncModeEnabled &amp;&amp; isClassFileLoaded.hasOwnProperty(className)) {
                    this.numPendingFiles--;
                    this.removeScriptElement(filePath);
                    delete isClassFileLoaded[className];
                }

                if (!isClassFileLoaded.hasOwnProperty(className)) {
                    isClassFileLoaded[className] = false;

                    classNameToFilePathMap[className] = filePath;

                    this.numPendingFiles++;

                    this.loadScriptFile(
                        filePath,
                        pass(this.onFileLoaded, [className, filePath], this),
                        pass(this.onFileLoadError, [className, filePath]),
                        this,
                        syncModeEnabled
                    );
                }
            }

            if (syncModeEnabled) {
                callback.call(scope);

                if (ln === 1) {
                    return Manager.get(className);
                }
            }

            return this;
        },

<span id='Carcasse-Loader-method-onFileLoaded'>        /**
</span>         * @private
         * @param {String} className
         * @param {String} filePath
         */
        onFileLoaded: function(className, filePath) {
            this.numLoadedFiles++;

            this.isClassFileLoaded[className] = true;
            this.isFileLoaded[filePath] = true;

            this.numPendingFiles--;

            if (this.numPendingFiles === 0) {
                this.refreshQueue();
            }

            //&lt;debug&gt;
            if (!this.syncModeEnabled &amp;&amp; this.numPendingFiles === 0 &amp;&amp; this.isLoading &amp;&amp; !this.hasFileLoadError) {
                var queue = this.queue,
                    missingClasses = [],
                    missingPaths = [],
                    requires,
                    i, ln, j, subLn;

                for (i = 0,ln = queue.length; i &lt; ln; i++) {
                    requires = queue[i].requires;

                    for (j = 0,subLn = requires.length; j &lt; subLn; j++) {
                        if (this.isClassFileLoaded[requires[j]]) {
                            missingClasses.push(requires[j]);
                        }
                    }
                }

                if (missingClasses.length &lt; 1) {
                    return;
                }

                missingClasses = Carcasse.Array.filter(Carcasse.Array.unique(missingClasses), function(item) {
                    return !this.requiresMap.hasOwnProperty(item);
                }, this);

                for (i = 0,ln = missingClasses.length; i &lt; ln; i++) {
                    missingPaths.push(this.classNameToFilePathMap[missingClasses[i]]);
                }

                throw new Error(&quot;The following classes are not declared even if their files have been &quot; +
                            &quot;loaded: '&quot; + missingClasses.join(&quot;', '&quot;) + &quot;'. Please check the source code of their &quot; +
                            &quot;corresponding files for possible typos: '&quot; + missingPaths.join(&quot;', '&quot;));
            }
            //&lt;/debug&gt;
        },

<span id='Carcasse-Loader-method-onFileLoadError'>        /**
</span>         * @private
         */
        onFileLoadError: function(className, filePath, errorMessage, isSynchronous) {
            this.numPendingFiles--;
            this.hasFileLoadError = true;

            //&lt;debug error&gt;
            throw new Error(&quot;[Carcasse.Loader] &quot; + errorMessage);
            //&lt;/debug&gt;
        },

<span id='Carcasse-Loader-method-addOptionalRequires'>        /**
</span>         * @private
         */
        addOptionalRequires: function(requires) {
            var optionalRequires = this.optionalRequires,
                i, ln, require;

            requires = arrayFrom(requires);

            for (i = 0, ln = requires.length; i &lt; ln; i++) {
                require = requires[i];

                arrayInclude(optionalRequires, require);
            }

            return this;
        },

<span id='Carcasse-Loader-method-triggerReady'>        /**
</span>         * @private
         */
        triggerReady: function(force) {
            var readyListeners = this.readyListeners,
                optionalRequires = this.optionalRequires,
                listener;

            if (this.isLoading || force) {
                this.isLoading = false;

                if (optionalRequires.length !== 0) {
                    // Clone then empty the array to eliminate potential recursive loop issue
                    optionalRequires = optionalRequires.slice();

                    // Empty the original array
                    this.optionalRequires.length = 0;

                    this.require(optionalRequires, pass(this.triggerReady, [true], this), this);
                    return this;
                }

                while (readyListeners.length) {
                    listener = readyListeners.shift();
                    listener.fn.call(listener.scope);

                    if (this.isLoading) {
                        return this;
                    }
                }
            }

            return this;
        },

        // duplicate definition (documented above)
        onReady: function(fn, scope, withDomReady, options) {
            var oldFn;

            if (withDomReady !== false &amp;&amp; Carcasse.onDocumentReady) {
                oldFn = fn;

                fn = function() {
                    Carcasse.onDocumentReady(oldFn, scope, options);
                };
            }

            if (!this.isLoading) {
                fn.call(scope);
            }
            else {
                this.readyListeners.push({
                    fn: fn,
                    scope: scope
                });
            }
        },

<span id='Carcasse-Loader-method-historyPush'>        /**
</span>         * @private
         * @param {String} className
         */
        historyPush: function(className) {
            var isInHistory = this.isInHistory;

            if (className &amp;&amp; this.isClassFileLoaded.hasOwnProperty(className) &amp;&amp; !isInHistory[className]) {
                isInHistory[className] = true;
                this.history.push(className);
            }

            return this;
        }
    });

    //&lt;/feature&gt;

<span id='Carcass-method-require'>    /**
</span>     * Convenient alias of {@link Carcasse.Loader#require}. Please see the introduction documentation of
     * {@link Carcasse.Loader} for examples.
     * @member Carcass
     * @method require
     * @inheritdoc Carcasse.Loader#require
     */
    Carcasse.require = alias(Loader, 'require');

<span id='Carcass-method-syncRequire'>    /**
</span>     * Synchronous version of {@link Carcass#require}, convenient alias of {@link Carcasse.Loader#syncRequire}.
     * @member Carcass
     * @method syncRequire
     * @inheritdoc Carcasse.Loader#syncRequire
     */
    Carcasse.syncRequire = alias(Loader, 'syncRequire');

<span id='Carcass-method-exclude'>    /**
</span>     * Convenient shortcut to {@link Carcasse.Loader#exclude}.
     * @member Carcass
     * @method exclude
     * @inheritdoc Carcasse.Loader#exclude
     */
    Carcasse.exclude = alias(Loader, 'exclude');

<span id='Carcass-method-onReady'>    /**
</span>     * Adds a listener to be notified when the document is ready and all dependencies are loaded.
     *
     * @param {Function} fn The method the event invokes.
     * @param {Object} [scope] The scope in which the handler function executes. Defaults to the browser window.
     * @param {Boolean} [options] Options object as passed to {@link Carcasse.Element#addListener}. It is recommended
     * that the options `{single: true}` be used so that the handler is removed on first invocation.
     * @member Carcass
     * @method onReady
     */
    Carcasse.onReady = function(fn, scope, options) {
        Loader.onReady(fn, scope, true, options);
    };

    Class.registerPreprocessor('loader', function(cls, data, hooks, continueFn) {
        var me = this,
            dependencies = [],
            className = Manager.getName(cls),
            i, j, ln, subLn, value, propertyName, propertyValue;

        /*
        Loop through the dependencyProperties, look for string class names and push
        them into a stack, regardless of whether the property's value is a string, array or object. For example:
        {
              extend: 'Carcasse.MyClass',
              requires: ['Carcasse.some.OtherClass'],
              mixins: {
                  observable: 'Carcasse.mixin.Observable';
              }
        }
        which will later be transformed into:
        {
              extend: Carcasse.MyClass,
              requires: [Carcasse.some.OtherClass],
              mixins: {
                  observable: Carcasse.mixin.Observable;
              }
        }
        */

        for (i = 0,ln = dependencyProperties.length; i &lt; ln; i++) {
            propertyName = dependencyProperties[i];

            if (data.hasOwnProperty(propertyName)) {
                propertyValue = data[propertyName];

                if (typeof propertyValue == 'string') {
                    dependencies.push(propertyValue);
                }
                else if (propertyValue instanceof Array) {
                    for (j = 0, subLn = propertyValue.length; j &lt; subLn; j++) {
                        value = propertyValue[j];

                        if (typeof value == 'string') {
                            dependencies.push(value);
                        }
                    }
                }
                else if (typeof propertyValue != 'function') {
                    for (j in propertyValue) {
                        if (propertyValue.hasOwnProperty(j)) {
                            value = propertyValue[j];

                            if (typeof value == 'string') {
                                dependencies.push(value);
                            }
                        }
                    }
                }
            }
        }

        if (dependencies.length === 0) {
            return;
        }

        //&lt;feature classSystem.loader&gt;
        //&lt;debug error&gt;
        var deadlockPath = [],
            requiresMap = Loader.requiresMap,
            detectDeadlock;

        /*
        Automatically detect deadlocks before-hand,
        will throw an error with detailed path for ease of debugging. Examples of deadlock cases:

        - A extends B, then B extends A
        - A requires B, B requires C, then C requires A

        The detectDeadlock function will recursively transverse till the leaf, hence it can detect deadlocks
        no matter how deep the path is.
        */

        if (className) {
            requiresMap[className] = dependencies;
            //&lt;debug&gt;
            if (!Loader.requiredByMap) Loader.requiredByMap = {};
            Carcasse.Array.each(dependencies, function(dependency){
                if (!Loader.requiredByMap[dependency]) Loader.requiredByMap[dependency] = [];
                Loader.requiredByMap[dependency].push(className);
            });
            //&lt;/debug&gt;
            detectDeadlock = function(cls) {
                deadlockPath.push(cls);

                if (requiresMap[cls]) {
                    if (Carcasse.Array.contains(requiresMap[cls], className)) {
                        throw new Error(&quot;Deadlock detected while loading dependencies! '&quot; + className + &quot;' and '&quot; +
                                deadlockPath[1] + &quot;' &quot; + &quot;mutually require each other. Path: &quot; +
                                deadlockPath.join(' -&gt; ') + &quot; -&gt; &quot; + deadlockPath[0]);
                    }

                    for (i = 0,ln = requiresMap[cls].length; i &lt; ln; i++) {
                        detectDeadlock(requiresMap[cls][i]);
                    }
                }
            };

            detectDeadlock(className);
        }

        //&lt;/debug&gt;
        //&lt;/feature&gt;

        Loader.require(dependencies, function() {
            for (i = 0,ln = dependencyProperties.length; i &lt; ln; i++) {
                propertyName = dependencyProperties[i];

                if (data.hasOwnProperty(propertyName)) {
                    propertyValue = data[propertyName];

                    if (typeof propertyValue == 'string') {
                        data[propertyName] = Manager.get(propertyValue);
                    }
                    else if (propertyValue instanceof Array) {
                        for (j = 0, subLn = propertyValue.length; j &lt; subLn; j++) {
                            value = propertyValue[j];

                            if (typeof value == 'string') {
                                data[propertyName][j] = Manager.get(value);
                            }
                        }
                    }
                    else if (typeof propertyValue != 'function') {
                        for (var k in propertyValue) {
                            if (propertyValue.hasOwnProperty(k)) {
                                value = propertyValue[k];

                                if (typeof value == 'string') {
                                    data[propertyName][k] = Manager.get(value);
                                }
                            }
                        }
                    }
                }
            }

            continueFn.call(me, cls, data, hooks);
        });

        return false;
    }, true, 'after', 'className');

    //&lt;feature classSystem.loader&gt;
<span id='Carcasse-Class-cfg-uses'>    /**
</span>     * @cfg {String[]} uses
     * @member Carcasse.Class
     * List of optional classes to load together with this class. These aren't necessarily loaded before
     * this class is created, but are guaranteed to be available before Carcasse.onReady listeners are
     * invoked
     */
    Manager.registerPostprocessor('uses', function(name, cls, data) {
        var uses = arrayFrom(data.uses),
            items = [],
            i, ln, item;

        for (i = 0,ln = uses.length; i &lt; ln; i++) {
            item = uses[i];

            if (typeof item == 'string') {
                items.push(item);
            }
        }

        Loader.addOptionalRequires(items);
    });

    Manager.onCreated(function(className) {
        this.historyPush(className);
    }, Loader);
    //&lt;/feature&gt;

})(Carcasse.ClassManager, Carcasse.Class, Carcasse.Function.flexSetter, Carcasse.Function.alias,
   Carcasse.Function.pass, Carcasse.Array.from, Carcasse.Array.erase, Carcasse.Array.include);</pre>
</body>
</html>
